# 소유권(ownership)과 대여(borrow)
- C 와 C++ 같은 저수준 언어에서 메모리 동적할당과 해제는 고질적인 문제였다.
- 메모리를 할당하고 해제하지 않는 경우(leak), 두 번 해제하는 경우(double-free), 해제된 포인터를 참조하는 경우(null-pointer-reference) 찾아내기 어려운 버그를 만들어낸다.
- 이를 배제하기 위해, 러스트는 GC와 같은 추상화를 전혀 사용하지 않으면서도 안전하게 메모리를 관리하기 위한 정책을 도입하였다. 
- 컴파일 타임에 대부분의 메모리 문제를 잡아내기 때문에 멀티 스레드 활용이 쉬워진다.

## 소유권 규칙
- 러스트는 deep copy가 무거운 타입들에 대해서 기본적으로 shallow copy를 한다.
- 각각의 메모리 값은 하나의 owner 변수만을 가진다. 이를 통해 double-free를 예방한다.
- shallow copy, 즉 주소 복사를 할 경우 복사된 변수로 소유권이 이동한다.
- owner가 스코프 밖으로 벗어나면 값은 해제된다. 이를 통해 memory-leak를 예방한다.
- ownership이 없는 포인터 변수를 사용하려 하면 컴파일이 되지 않는다.

## 대여
- 위와 같은 정책을 사용할 경우, 변수를 한 번에 하나의 함수에서밖에 사용할 수 없으며, 사용 후 반드시 리턴해줘야 하는 불편함이 생긴다.
- 이를 해결하기 위해 소유권 없이 변수를 사용하는 '대여(borrowing)'를 도입하였다.
- 변수의 reference 를 전달함으로서 소유권 없이 변수를 사용할 수 있다.

## Mutable reference
- reference는 mutable 과 immutable 이 있다. immutable reference 로는 내용을 수정할 수 없다.
- mutable referece는 한 개만 존재할 수 있으며, immutable reference 는 여러 개 존재할 수 있다. 이 정책으로 data race를 예방한다.
- lifetime: 소유권이 있는 변수가 reference가 해제되기 전 해제될 경우 dangling reference 버그가 발생할 수 있다. 이런 경우 컴파일이 되지 않는다.

## 슬라이스
- String이나 str, 배열 등의 reference를 넘겨줄 때 일부만 넘겨주고 싶을 수 있다.
- 이럴 경우, 특정 인덱스 범위를 reference를 생성하여 슬라이스를 만들 수 있다.
- 함수 리턴값으로 불변 참조자를 넘겨 주면, 부모 함수 내에서 해당 변수를 변경할 수 없게 된다. 이 방법으로 참조가 원래와 달라지는 버그를 컴파일 타임에 막을 수 있다.